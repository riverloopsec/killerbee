#!/usr/bin/env python3

from typing import Optional, Dict, Union, Any

'''
zbdump - a tcpdump-like tool for ZigBee/IEEE 802.15.4 networks

Compatible with Wireshark 1.1.2 and later (jwright@willhackforsushi.com)
The -p flag adds CACE PPI headers to the PCAP (ryan@rmspeers.com)
'''
import sys
import signal
import argparse
import os
from scapy.all import Dot15d4FCS # type: ignore
from killerbee import KillerBee, PcapDumper, DainTreeDumper, DLT_IEEE802_15_4
from killerbee.scapy_extensions import kbgetpanid

packetcount: int = 0
kb: Optional[KillerBee] = None
pcap_dumper: Optional[PcapDumper] = None
daintree_dumper: Optional[DainTreeDumper] = None
rf_freq_mhz: int = 0
panid: Optional[int] = None 
unbuffered: Optional[Any] = None

def interrupt(signum, frame):
    kb.sniffer_off()
    kb.close()

    if pcap_dumper is not None:
        pd.close()
    if daintree_dumper is not None:
        dt.close()

    print(("\n{0} packets captured".format(packetcount)))
    sys.exit(0)

def dump_packets(args):
  while args.count != packetcount:
      packet: Optional[Dict[Union[int, str], Any]] = kb.pnext()

      if packet is None:
          continue

      if panid is not None:
          pan, layer = kbgetpanid(Dot15d4FCS(packet['bytes']))

      # packet['vaildcrc'] is True if CRC is correct, check removed to have promiscous capture regardless of CRC
      # if PAN filter active, only process correct PAN or ACK
      if panid is None or panid == pan: # and packet['validcrc']:
          packetcount+=1
          if args.verbose:
              if unbuffered is None:
                print('ERROR: Could not open stdout for verbose mode.', file=sys.stderr)
                sys.exit(0)
              else:
                unbuffered.write('.')
          if pcap_dumper is not None:
              pcap_dumper.pcap_dump(packet['bytes'], ant_dbm=packet['dbm'], freq_mhz=rf_freq_mhz)
          if daintree_dumper is not None:
              daintree_dumper.pwrite(packet['bytes'])

def main():
  parser = argparse.ArgumentParser(description=__doc__)
  parser.add_argument('-i', '--iface', '--dev', action='store', dest='devstring',
                      help='Path to device interface. E.g. /dev/ttyUSB0, /dev/tty.usbserial-ABC')
  parser.add_argument('-h', '--hardware', action='store',
                      help='Name of the radio hardware being used. E.g. apimote, telosb')
  parser.add_argument('-w', '--pcapfile', action='store', default=None,
                      help='Path to destination pcap file.')
  parser.add_argument('-W', '--dsnafile', action='store', default=None,
                      help='Path to destination daintree file.')
  parser.add_argument('-p', '--ppi', action='store_true', default=False,
                      help='')
  parser.add_argument('-P', '--pan_id_hex', action='store', default=None,
                      help='Hex string of Pan ID to filter on.')
  parser.add_argument('-c', '-f', '--channel', action='store', type=int, default=None,
                      help='ZigBee channel to listen on.')
  parser.add_argument('-s', '--subghz_page', action='store', type=int, default=0,
                      help='')
  parser.add_argument('-n', '--count', action='store', type=int, default=-1,
                      help='Number of packets to capture. Default no-limit.')
  parser.add_argument('-v', action='store_true', dest='verbose',
                      help='Verbose mode will output to stdout each time a packet is received.')
  args = parser.parse_args()


  if args.verbose:
      unbuffered = os.fdopen(sys.stdout.fileno(), 'w', 0)

  if args.channel is None:
      print("ERROR: Must specify a channel.", file=sys.stderr)
      sys.exit(1)

  if args.pcapfile is None and args.dsnafile is None:

      print("ERROR: Must specify a savefile with -w (libpcap) or -W (DainTree SNA)", file=sys.stderr)
      sys.exit(1)

  elif args.pcapfile is not None:
      pcap_dumper = PcapDumper(DLT_IEEE802_15_4, args.pcapfile, ppi=args.ppi)
  elif args.dsnafile is not None:
      daintree_dumper = DainTreeDumper(args.dsnafile)

  if args.pan_id_hex:
      panid: Optional[int] = int(args.pan_id_hex, 16)
  else:
      panid = None

  packetcount = 0

  kb = KillerBee(device=args.devstring, hardware=args.hardware)

  signal.signal(signal.SIGINT, interrupt)
  if not kb.is_valid_channel(args.channel, args.subghz_page):
      print("ERROR: Must specify a valid IEEE 802.15.4 channel for the selected device.", file=sys.stderr)
      kb.close()
      sys.exit(1)

  rf_freq_mhz = kb.frequency(args.channel, args.subghz_page) / 1000.0
  print(("zbdump: listening on \'{0}\', channel {1}, page {2} ({3} MHz), link-type DLT_IEEE802_15_4, capture size 127 bytes".format(kb.get_dev_info()[0], args.channel, args.subghz_page, rf_freq_mhz)))

  kb.set_channel(args.channel, args.subghz_page)
  kb.sniffer_on()

  dump_packets(args)

  kb.sniffer_off()
  kb.close()
  if pcap_dumper is not None:
      pd.close()
  if daintree_dumper is not None:
      dt.close()

  print(("{0} packets captured".format(packetcount)))

if __name__ == "__main__":
  main()
